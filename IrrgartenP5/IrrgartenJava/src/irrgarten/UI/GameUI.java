/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package irrgarten.UI;

import irrgarten.Directions;
import irrgarten.GameState;
import java.awt.Color;
import java.awt.GridLayout;
import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.SwingConstants;

/**
 *
 * @author Moha
 */
public class GameUI extends javax.swing.JFrame implements UI{

    private Directions selectedDirection;

    /**
     * Creates new form GameUI
     */
    public GameUI() {
        super("Irrgarten Game");
        initComponents(); // Inicializar componentes gr√°ficos
        setVisible(true); // Hacer visible la ventana
    }



    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        directionPanel = new javax.swing.JPanel();
        upButton = new javax.swing.JButton();
        leftButton = new javax.swing.JButton();
        downButton = new javax.swing.JButton();
        rightButton = new javax.swing.JButton();
        gameDataPanel = new javax.swing.JPanel();
        labyrinthArea = new javax.swing.JScrollPane();
        labyrinthPanel = new javax.swing.JPanel();
        playersArea = new javax.swing.JScrollPane();
        playersAreaText = new javax.swing.JTextArea();
        monstersArea = new javax.swing.JScrollPane();
        monstersAreaText = new javax.swing.JTextArea();
        logArea = new javax.swing.JScrollPane();
        logAreaText = new javax.swing.JTextArea();
        jPanel3 = new javax.swing.JPanel();
        currentPlayerLabel = new javax.swing.JLabel();
        winnerLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setPreferredSize(new java.awt.Dimension(800, 600));

        directionPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));
        directionPanel.setLayout(new java.awt.BorderLayout());

        upButton.setBackground(new java.awt.Color(255, 153, 51));
        upButton.setText("UP");
        upButton.setPreferredSize(new java.awt.Dimension(100, 60));
        upButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                upButtonActionPerformed(evt);
            }
        });
        directionPanel.add(upButton, java.awt.BorderLayout.NORTH);

        leftButton.setBackground(new java.awt.Color(255, 153, 51));
        leftButton.setText("LEFT");
        leftButton.setPreferredSize(new java.awt.Dimension(115, 23));
        leftButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                leftButtonActionPerformed(evt);
            }
        });
        directionPanel.add(leftButton, java.awt.BorderLayout.WEST);

        downButton.setBackground(new java.awt.Color(255, 153, 51));
        downButton.setText("DOWN");
        downButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                downButtonActionPerformed(evt);
            }
        });
        directionPanel.add(downButton, java.awt.BorderLayout.CENTER);

        rightButton.setBackground(new java.awt.Color(255, 153, 51));
        rightButton.setText("RIGHT");
        rightButton.setPreferredSize(new java.awt.Dimension(115, 23));
        rightButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rightButtonActionPerformed(evt);
            }
        });
        directionPanel.add(rightButton, java.awt.BorderLayout.LINE_END);

        getContentPane().add(directionPanel, java.awt.BorderLayout.SOUTH);

        gameDataPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));
        gameDataPanel.setLayout(new java.awt.GridLayout(2, 2));

        labyrinthArea.setBorder(javax.swing.BorderFactory.createTitledBorder("Labyrinth"));

        labyrinthPanel.setLayout(new java.awt.GridLayout());
        labyrinthArea.setViewportView(labyrinthPanel);

        gameDataPanel.add(labyrinthArea);

        playersArea.setBorder(javax.swing.BorderFactory.createTitledBorder("Player"));

        playersAreaText.setColumns(20);
        playersAreaText.setRows(5);
        playersArea.setViewportView(playersAreaText);

        gameDataPanel.add(playersArea);

        monstersArea.setBorder(javax.swing.BorderFactory.createTitledBorder("Monster"));

        monstersAreaText.setColumns(20);
        monstersAreaText.setRows(5);
        monstersArea.setViewportView(monstersAreaText);

        gameDataPanel.add(monstersArea);

        logArea.setBorder(javax.swing.BorderFactory.createTitledBorder("Game Log"));

        logAreaText.setColumns(20);
        logAreaText.setRows(5);
        logArea.setViewportView(logAreaText);

        gameDataPanel.add(logArea);

        getContentPane().add(gameDataPanel, java.awt.BorderLayout.CENTER);

        jPanel3.setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));
        jPanel3.setLayout(new java.awt.GridLayout(1, 2));

        currentPlayerLabel.setFont(new java.awt.Font("SansSerif", 1, 16)); // NOI18N
        currentPlayerLabel.setText("jLabel1");
        jPanel3.add(currentPlayerLabel);
        currentPlayerLabel.getAccessibleContext().setAccessibleName("Jugador actual:");
        currentPlayerLabel.getAccessibleContext().setAccessibleDescription("");

        winnerLabel.setFont(new java.awt.Font("SansSerif", 1, 16)); // NOI18N
        winnerLabel.setText("jLabel2");
        jPanel3.add(winnerLabel);
        winnerLabel.getAccessibleContext().setAccessibleName("Estado del juego: ");

        getContentPane().add(jPanel3, java.awt.BorderLayout.NORTH);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void upButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_upButtonActionPerformed
        selectedDirection = Directions.UP;
        synchronized (this) {
        notify(); // Desbloquea el hilo en `nextMove`
    }

    }//GEN-LAST:event_upButtonActionPerformed

    private void downButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_downButtonActionPerformed
        selectedDirection = Directions.DOWN;
        synchronized (this){
        notify();} // Desbloquea el hilo en `nextMove`
    }//GEN-LAST:event_downButtonActionPerformed

    private void leftButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_leftButtonActionPerformed
        selectedDirection = Directions.LEFT;
        synchronized (this) {
        notify(); // Desbloquea el hilo en `nextMove`
        }
    }//GEN-LAST:event_leftButtonActionPerformed

    private void rightButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rightButtonActionPerformed
        selectedDirection = Directions.RIGHT;
        synchronized (this) {
        notify(); // Desbloquea el hilo en `nextMove`
        }
    }//GEN-LAST:event_rightButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel currentPlayerLabel;
    private javax.swing.JPanel directionPanel;
    private javax.swing.JButton downButton;
    private javax.swing.JPanel gameDataPanel;
    private javax.swing.JPanel jPanel3;
    protected javax.swing.JScrollPane labyrinthArea;
    private javax.swing.JPanel labyrinthPanel;
    private javax.swing.JButton leftButton;
    private javax.swing.JScrollPane logArea;
    private javax.swing.JTextArea logAreaText;
    private javax.swing.JScrollPane monstersArea;
    private javax.swing.JTextArea monstersAreaText;
    public javax.swing.JScrollPane playersArea;
    private javax.swing.JTextArea playersAreaText;
    private javax.swing.JButton rightButton;
    private javax.swing.JButton upButton;
    private javax.swing.JLabel winnerLabel;
    // End of variables declaration//GEN-END:variables
  
    
    @Override
    public void disableInteraction() {
        upButton.setEnabled(false);
        downButton.setEnabled(false);
        leftButton.setEnabled(false);
        rightButton.setEnabled(false);
    }

    @Override
    public void showGame(GameState gameState) {
        // Mostrar el laberinto
        /*String formattedLabyrinth = formatLabyrinth(gameState.getLabyrinth());
        labyrinthAreaText.setText(formattedLabyrinth);
*/
        updateLabyrinth(gameState.getLabyrinth());

        // Formatear jugadores
        String formattedPlayers = cleanOutput(gameState.getPlayers());
        playersAreaText.setText(formattedPlayers);

        // Formatear monstruos
        String formattedMonsters = cleanOutput(gameState.getMonsters());
        monstersAreaText.setText(formattedMonsters);

        // Mostrar el registro del juego
        logAreaText.setText(gameState.getLog());

        // Mostrar el jugador actual
        currentPlayerLabel.setText("Current Player: Player #" + gameState.getCurrentPlayer());

        // Mostrar el estado del juego
        winnerLabel.setText(gameState.isWinner() ? "Winner!" : "Ongoing");
        winnerLabel.setForeground(gameState.isWinner() ? Color.GREEN : Color.RED);

        // Refrescar la interfaz
        repaint();
    }

    private String cleanOutput(String input) {
        StringBuilder result = new StringBuilder();

        // Dividir por delimitadores comunes (coma seguido de Monstruo/Player/Fuzzy o cierre de bloque)
        String[] elements = input.split(",(?=\\s*Monstruo|\\s*Player|\\s*Fuzzy Player)");

        for (String element : elements) {
            if (!element.trim().isEmpty()) {
                // Eliminar corchetes finales sobrantes
                element = element.replace("]", "").trim();

                // Formatear atributos clave
                element = element.replace("Health:", "\n  Health:")
                                 .replace("Strength:", "\n  Strength:")
                                 .replace("Intelligence:", "\n  Intelligence:")
                                 .replace("Position:", "\n  Position:")
                                 .replace("Weapons:", "\nWeapons:")
                                 .replace("Shields:", "\nShields:");

                // A√±adir salto de l√≠nea entre cada jugador o monstruo
                result.append(element.trim()).append("\n\n");
            }
        }

        return result.toString();
    }


    @Override
    public Directions nextMove() {
        synchronized (this) {
            try {
                wait(); // Espera hasta que el usuario seleccione una direcci√≥n
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return selectedDirection;
    }
/*
    private String formatLabyrinth(String input) {
        StringBuilder result = new StringBuilder();

        // Dividir el laberinto en filas
        String[] rows = input.split("\n");

        for (String row : rows) {
            // Dividir cada fila en celdas
            String[] cells = row.split(" ");
            for (String cell : cells) {
                // Formatear cada celda para que tenga un ancho fijo (por ejemplo, 3 caracteres)
                result.append(String.format("| %-3s", cell));
            }
            result.append("|\n");

            // A√±adir un borde horizontal despu√©s de cada fila
            result.append("+");
            for (int i = 0; i < cells.length; i++) {
                result.append("---+");
            }
            result.append("\n");
        }

        return result.toString();
    }
*/

    private void updateLabyrinth(String labyrinth) {
        // Limpia todos los componentes actuales del panel antes de agregar el nuevo estado del laberinto.
        labyrinthPanel.removeAll();

        // Divide el laberinto en filas utilizando el salto de l√≠nea como delimitador.
        String[] rows = labyrinth.split("\n");
        int rowCount = rows.length; // N√∫mero de filas del laberinto.
        int colCount = rows[0].split(" ").length; // N√∫mero de columnas, basado en la primera fila.

        // Configura el dise√±o del panel como una cuadr√≠cula con las dimensiones del laberinto.
        labyrinthPanel.setLayout(new GridLayout(rowCount, colCount));

        // Recorre cada fila del laberinto.
        for (String row : rows) {
            // Divide la fila en celdas utilizando el espacio como delimitador.
            String[] cells = row.split(" ");

            // Recorre cada celda de la fila.
            for (String cell : cells) {
                // Crea un JLabel para representar la celda.
                JLabel cellLabel = new JLabel(cell, SwingConstants.CENTER); // El texto se centra horizontalmente.
                cellLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK)); // A√±ade un borde negro alrededor de la celda.
                cellLabel.setOpaque(true); // Permite establecer el color de fondo.

                // Opcional: Colorea las celdas seg√∫n su contenido.
                switch (cell) {
                    case "M": // Monstruo
                        cellLabel.setBackground(Color.RED); // Fondo rojo.
                        cellLabel.setForeground(Color.WHITE); // Texto blanco.
                        break;
                    case "E": // Salida
                        cellLabel.setBackground(Color.GREEN); // Fondo verde.
                        cellLabel.setForeground(Color.BLACK); // Texto negro.
                        break;
                    case "1": // Jugador 1
                    case "0": // Jugador 0
                        cellLabel.setBackground(Color.BLUE); // Fondo azul.
                        cellLabel.setForeground(Color.WHITE); // Texto blanco.
                        break;
                    case "-": // Espacio vac√≠o
                        cellLabel.setBackground(Color.LIGHT_GRAY); // Fondo gris claro.
                        break;
                    default: // Otros casos
                        cellLabel.setBackground(Color.WHITE); // Fondo blanco.
                        break;
                }

                // A√±ade la celda (JLabel) al panel del laberinto.
                labyrinthPanel.add(cellLabel);
            }
        }

        // Revalida el dise√±o del panel para aplicar los cambios.
        labyrinthPanel.revalidate();
        // Fuerza la actualizaci√≥n visual del panel.
        labyrinthPanel.repaint();
    }



}
